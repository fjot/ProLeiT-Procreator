"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const helpers_1 = require("./helpers");
function resolveRelevantMappings(resolvers, path, allMappings) {
    const result = [];
    const splitted = path.split('.');
    if (splitted.length === 2) {
        const typeName = splitted[0];
        const fieldName = splitted[1];
        if (fieldName === '*') {
            return Object.keys(resolvers[typeName])
                .map(field => `${typeName}.${field}`)
                .filter(mapItem => !allMappings[mapItem]);
        }
        else {
            return [path];
        }
    }
    return result;
}
/**
 * Wraps the resolvers object with the resolvers composition objects.
 * Implemented as a simple and basic middleware mechanism.
 *
 * @param resolvers - resolvers object
 * @param mapping - resolvers composition mapping
 * @hidden
 */
function composeResolvers(resolvers, mapping = {}) {
    Object.keys(mapping).map((resolverPath) => {
        const composeFns = mapping[resolverPath];
        const relevantFields = resolveRelevantMappings(resolvers, resolverPath, mapping);
        relevantFields.forEach((path) => {
            const fns = helpers_1.chainFunctions([...helpers_1.asArray(composeFns), () => lodash_1.get(resolvers, path)]);
            lodash_1.set(resolvers, path, fns());
        });
    });
    return resolvers;
}
exports.composeResolvers = composeResolvers;
//# sourceMappingURL=resolvers-composition.js.map