import { existsSync } from 'fs';
import { extname, isAbsolute, resolve as resolvePath } from 'path';
import * as isValidPath from 'is-valid-path';
import { buildASTSchema, buildClientSchema, GraphQLSchema, parse } from 'graphql';
export class SchemaFromExport {
    canHandle(pointerToSchema) {
        const fullPath = isAbsolute(pointerToSchema) ? pointerToSchema : resolvePath(process.cwd(), pointerToSchema);
        return isValidPath(pointerToSchema) && existsSync(fullPath) && extname(pointerToSchema) !== '.json';
    }
    async handle(file, _options) {
        const fullPath = isAbsolute(file) ? file : resolvePath(process.cwd(), file);
        if (existsSync(fullPath)) {
            const exports = require(fullPath);
            if (exports) {
                let rawExport = exports.default || exports.schema || exports;
                if (rawExport) {
                    let schema = await rawExport;
                    try {
                        const schemaResult = await this.resolveSchema(schema);
                        return schemaResult;
                    }
                    catch (e) {
                        throw new Error('Exported schema must be of type GraphQLSchema, text, AST, or introspection JSON.');
                    }
                }
                else {
                    throw new Error(`Invalid export from export file ${fullPath}: missing default export or 'schema' export!`);
                }
            }
            else {
                throw new Error(`Invalid export from export file ${fullPath}: empty export!`);
            }
        }
        else {
            throw new Error(`Unable to locate introspection from export file: ${fullPath}`);
        }
    }
    isSchemaText(obj) {
        return typeof obj === 'string';
    }
    isWrappedSchemaJson(obj) {
        const json = obj;
        return json.data !== undefined && json.data.__schema !== undefined;
    }
    isSchemaJson(obj) {
        const json = obj;
        return json !== undefined && json.__schema !== undefined;
    }
    isSchemaObject(obj) {
        return obj instanceof GraphQLSchema;
    }
    isSchemaAst(obj) {
        return obj.kind !== undefined;
    }
    isPromise(obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    }
    async resolveSchema(schema) {
        if (this.isSchemaObject(schema)) {
            return schema;
        }
        else if (this.isSchemaAst(schema)) {
            return buildASTSchema(schema);
        }
        else if (this.isSchemaText(schema)) {
            const ast = parse(schema);
            return buildASTSchema(ast);
        }
        else if (this.isWrappedSchemaJson(schema)) {
            return buildClientSchema(schema.data);
        }
        else if (this.isSchemaJson(schema)) {
            return buildClientSchema(schema);
        }
        else {
            throw new Error('Unexpected schema type provided!');
        }
    }
}
//# sourceMappingURL=schema-from-export.js.map